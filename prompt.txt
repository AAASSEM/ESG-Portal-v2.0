The Problem

Worker Timeout: Your Gunicorn worker is timing out (default 30 seconds) during signup
Email Processing: The signup process is trying to send verification emails, which is taking too long
Transaction Issues: The database transaction completes, but the response never makes it back to the client

Solutions
1. Increase Gunicorn Worker Timeout
Update your Render start command or create a gunicorn.conf.py:
python# gunicorn.conf.py (create this in your backend folder)
bind = "0.0.0.0:10000"
workers = 2
timeout = 120  # Increase timeout to 120 seconds
worker_class = "sync"
max_requests = 1000
max_requests_jitter = 50
Then update your Render start command to:
bashcd backend && gunicorn esg_backend.wsgi:application --config gunicorn.conf.py
2. Fix Email Configuration Issues
The email sending is likely causing the timeout. Update your settings.py:
python# Quick fix - disable email temporarily to test if that's the issue
USE_REAL_EMAIL = False  # Force console email backend
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
3. Add Async Email Sending
For production, implement async email sending to prevent timeouts:
# core/views.py or wherever your signup view is

import json
import logging
from django.http import JsonResponse
from django.contrib.auth import get_user_model
from django.db import transaction
from django.core.exceptions import ValidationError
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

logger = logging.getLogger(__name__)
User = get_user_model()

@csrf_exempt  # Temporarily disable CSRF for debugging
def signup(request):
    """Handle user signup with proper error handling and timeout prevention"""
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Parse request data
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            logger.error("Invalid JSON in signup request")
            return JsonResponse({'error': 'Invalid JSON format'}, status=400)
        
        # Validate required fields
        required_fields = ['email', 'password', 'first_name', 'last_name']
        missing_fields = [field for field in required_fields if not data.get(field)]
        
        if missing_fields:
            return JsonResponse({
                'error': f'Missing required fields: {", ".join(missing_fields)}'
            }, status=400)
        
        # Check if user already exists
        if User.objects.filter(email=data['email']).exists():
            return JsonResponse({'error': 'User with this email already exists'}, status=400)
        
        # Create user with transaction
        with transaction.atomic():
            user = User.objects.create_user(
                email=data['email'],
                username=data['email'],  # Use email as username
                password=data['password'],
                first_name=data.get('first_name', ''),
                last_name=data.get('last_name', ''),
                is_active=False  # Require email verification
            )
            
            # Create company profile if data provided
            if data.get('company_name'):
                from core.models import CompanyProfile
                CompanyProfile.objects.create(
                    user=user,
                    company_name=data['company_name'],
                    industry=data.get('industry', 'other'),
                    emirate=data.get('emirate', 'dubai'),
                    website=data.get('website', ''),
                    description=data.get('description', '')
                )
            
            # Don't send email synchronously - use a signal or background task
            # The email sending is already handled by signals based on your logs
            
            logger.info(f"User created successfully: {user.email}")
        
        # Return success immediately
        return JsonResponse({
            'success': True,
            'message': 'Account created successfully. Please check your email for verification.',
            'email': user.email
        }, status=201)
        
    except ValidationError as e:
        logger.error(f"Validation error in signup: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)
        
    except Exception as e:
        logger.error(f"Unexpected error in signup: {str(e)}", exc_info=True)
        return JsonResponse({
            'error': 'An error occurred during signup. Please try again.'
        }, status=500)

# Alternative: Class-based view with better error handling
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response

@api_view(['POST'])
@permission_classes([AllowAny])
def signup_api(request):
    """REST API endpoint for signup"""
    
    try:
        data = request.data
        
        # Validate data
        required_fields = ['email', 'password', 'first_name', 'last_name']
        for field in required_fields:
            if not data.get(field):
                return Response(
                    {'error': f'{field} is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        # Check existing user
        if User.objects.filter(email=data['email']).exists():
            return Response(
                {'error': 'User with this email already exists'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Create user
        with transaction.atomic():
            user = User.objects.create_user(
                email=data['email'],
                username=data['email'],
                password=data['password'],
                first_name=data['first_name'],
                last_name=data['last_name'],
                is_active=False
            )
            
            # Handle company profile
            if data.get('company_name'):
                from core.models import CompanyProfile
                CompanyProfile.objects.create(
                    user=user,
                    company_name=data['company_name'],
                    industry=data.get('industry', 'other'),
                    emirate=data.get('emirate', 'dubai')
                )
        
        return Response({
            'success': True,
            'message': 'Registration successful. Please check your email.',
            'email': user.email
        }, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        logger.error(f"Signup error: {str(e)}", exc_info=True)
        return Response(
            {'error': 'Registration failed. Please try again.'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

4. Update Frontend to Handle the Response:

// AuthContext.js - Improved signup function

const signup = async (formData) => {
    try {
        const response = await fetch(`${API_BASE_URL}/api/auth/signup/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            credentials: 'include', // Important for CORS
            body: JSON.stringify(formData),
        });

        // Get response text first to handle non-JSON responses
        const responseText = await response.text();
        
        // Try to parse as JSON
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            console.error('Response is not JSON:', responseText);
            
            // Handle different HTTP status codes
            if (response.status === 502) {
                throw new Error('Server error. Please try again later.');
            } else if (response.status === 500) {
                throw new Error('Internal server error. Please contact support.');
            } else {
                throw new Error(`Unexpected response: ${responseText}`);
            }
        }

        // Check if response is successful
        if (!response.ok) {
            // Handle specific error messages from backend
            const errorMessage = data.error || data.message || 'Signup failed';
            throw new Error(errorMessage);
        }

        // Success - handle the response
        console.log('Signup successful:', data);
        
        // Show success message
        if (data.message) {
            // You might want to show this in a toast or notification
            alert(data.message);
        }
        
        // Don't try to parse user/token if email verification is required
        if (data.success && !data.user) {
            // Redirect to email verification page or show message
            return {
                success: true,
                requiresVerification: true,
                email: data.email
            };
        }
        
        // If user data is returned (auto-login after signup)
        if (data.user) {
            setUser(data.user);
            localStorage.setItem('user', JSON.stringify(data.user));
            
            if (data.token) {
                localStorage.setItem('token', data.token);
            }
        }
        
        return data;
        
    } catch (error) {
        console.error('Signup error:', error);
        
        // Provide user-friendly error messages
        let userMessage = 'Registration failed. ';
        
        if (error.message.includes('email already exists')) {
            userMessage = 'This email is already registered. Please login or use a different email.';
        } else if (error.message.includes('timeout')) {
            userMessage = 'Request timed out. Please check your connection and try again.';
        } else if (error.message.includes('Network')) {
            userMessage = 'Network error. Please check your internet connection.';
        } else {
            userMessage += error.message;
        }
        
        throw new Error(userMessage);
    }
};

// Improved user check function
const checkAuthUser = async () => {
    try {
        const response = await fetch(`${API_BASE_URL}/api/auth/user/`, {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
            },
        });

        // 401 is expected for non-authenticated users
        if (response.status === 401) {
            console.log('User not authenticated (expected for new visitors)');
            setUser(null);
            setLoading(false);
            return;
        }

        if (response.ok) {
            const userData = await response.json();
            setUser(userData);
            localStorage.setItem('user', JSON.stringify(userData));
        } else {
            // Unexpected status code
            console.error('Unexpected response status:', response.status);
            setUser(null);
        }
    } catch (error) {
        // Network errors or other issues
        console.error('Auth check error:', error);
        setUser(null);
    } finally {
        setLoading(false);
    }
};

// Add timeout handling
const fetchWithTimeout = (url, options = {}, timeout = 30000) => {
    return Promise.race([
        fetch(url, options),
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Request timeout')), timeout)
        )
    ]);
};

5. Quick Deployment Fix for Render
Add these environment variables in your Render dashboard:
bash# In Render Environment Variables
DEBUG=False
USE_REAL_EMAIL=False  # Disable email temporarily
DATABASE_URL=your-postgres-url-here
SECRET_KEY=your-secret-key-here
6. Update your Build Command
In Render settings, update your build command:
bashcd backend && pip install -r requirements.txt && python manage.py migrate && python manage.py collectstatic --noinput
7. Update Start Command
bashcd backend && gunicorn esg_backend.wsgi:application --timeout 120 --workers 2
Testing Steps

First, test locally to ensure signup works:

bashpython manage.py runserver
# Try signup via Postman or curl

Check the actual error by adding more logging:

python# In your signup view
import traceback
try:
    # your code
except Exception as e:
    print(f"SIGNUP ERROR: {str(e)}")
    print(traceback.format_exc())
    raise

Monitor Render logs during signup to see the actual error.

The main issue is the worker timeout during email sending. Start by disabling email (set USE_REAL_EMAIL=False) and increasing the timeout. Once signup works, you can re-enable email with proper async handling.RetryClaude can make mistakes. Please double-check responses.
